#![allow(clippy::too_many_arguments)]
#![allow(dead_code)]
#![allow(clippy::enum_variant_names)]
#![allow(clippy::indexing_slicing)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]

/* automatically generated by rust-bindgen 0.72.1 */

pub const LIBFW_NEXT_PROTO_TCP: u8 = 0;
pub const LIBFW_NEXT_PROTO_UDP: u8 = 1;
pub const LIBFW_NEXT_PROTO_ICMP: u8 = 2;
pub const LIBFW_NEXT_PROTO_ICMPV6: u8 = 3;
pub const LIBFW_ICMP_TYPE_ECHO_REPLY: u8 = 0;
pub const LIBFW_ICMP_TYPE_DESTINATION_UNREACHABLE: u8 = 3;
pub const LIBFW_ICMP_TYPE_REDIRECT_MESSAGE: u8 = 5;
pub const LIBFW_ICMP_TYPE_ECHO_REQUEST: u8 = 8;
pub const LIBFW_ICMP_TYPE_ROUTER_ADVERTISEMENT: u8 = 9;
pub const LIBFW_ICMP_TYPE_ROUTER_SOLICITATION: u8 = 10;
pub const LIBFW_ICMP_TYPE_TIME_EXCEEDED: u8 = 11;
pub const LIBFW_ICMP_TYPE_PARAMETER_PROBLEM: u8 = 12;
pub const LIBFW_ICMP_TYPE_TIMESTAMP: u8 = 13;
pub const LIBFW_ICMP_TYPE_TIMESTAMP_REPLY: u8 = 14;
pub const LIBFW_VERDICT_ACCEPT: u8 = 0;
pub const LIBFW_VERDICT_DROP: u8 = 1;
pub const LIBFW_VERDICT_REJECT: u8 = 2;
pub const LIBFW_CONTRACK_STATE_NEW: u8 = 0;
pub const LIBFW_CONTRACK_STATE_ESTABLISHED: u8 = 1;
pub const LIBFW_CONTRACK_STATE_INVALID: u8 = 2;
pub const LIBFW_CONTRACK_STATE_RELATED: u8 = 3;
pub const LIBFW_CONTRACK_STATE_CLOSED: u8 = 4;
pub const LIBFW_DIRECTION_OUTBOUND: u8 = 0;
pub const LIBFW_DIRECTION_INBOUND: u8 = 1;
pub const LIBFW_IP_TYPE_V4: u8 = 0;
pub const LIBFW_IP_TYPE_V6: u8 = 1;
pub const LIBFW_FILTER_ASSOCIATED_DATA: u8 = 0;
pub const LIBFW_FILTER_CONNTRACK_STATE: u8 = 1;
pub const LIBFW_FILTER_SRC_NETWORK: u8 = 2;
pub const LIBFW_FILTER_DST_NETWORK: u8 = 3;
pub const LIBFW_FILTER_DIRECTION: u8 = 4;
pub const LIBFW_FILTER_NEXT_LVL_PROTO: u8 = 5;
pub const LIBFW_FILTER_TCP_FLAGS: u8 = 6;
pub const LIBFW_FILTER_ICMP_TYPE: u8 = 7;

#[repr(u32)]
#[doc = " Log levels used in LibfwLogCallback\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LibfwLogLevel {
    LibfwLogLevelTrace = 0,
    LibfwLogLevelDebug = 1,
    LibfwLogLevelInfo = 2,
    LibfwLogLevelWarn = 3,
    LibfwLogLevelErr = 4,
}

pub mod LibfwResult {
    #[doc = " Possible FW results\n"]
    pub type Type = ::std::os::raw::c_uint;
    pub const LibfwSuccess: Type = 0;
    pub const LibfwErrorMalformedIpPacket: Type = 1;
    pub const LibfwErrorMalformedUdpPacket: Type = 2;
    pub const LibfwErrorMalformedTcpPacket: Type = 3;
    pub const LibfwErrorMalformedIcmpPacket: Type = 4;
    pub const LibfwErrorUnexpectedProtocol: Type = 5;
    pub const LibfwErrorInvalidIcmpErrorPayload: Type = 6;
    pub const LibfwErrorUnexpectedPacketType: Type = 7;
    pub const LibfwErrorNullPointer: Type = 8;
    pub const LibfwErrorNotImplemented: Type = 9;
    pub const LibfwErrorInvalidChain: Type = 10;
    pub const LibfwErrorInvalidConfig: Type = 11;
}

#[repr(u32)]
#[doc = " Possible verdicts for packets.\n\n Note: From the libfw integrators perspective, LibfwVerdictReject is the same as\n packet injection + drop. Reject is here just for informational purposes, therefore\n anytime libfw returns LibfwVerdictReject - relevant packet should be dropped in the\n same manner as LibfwVerdictDrop. But differentiating these two may be useful for\n logging or metrics or similar kind of purposes.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum LibfwVerdict {
    LibfwVerdictAccept = 0,
    LibfwVerdictDrop = 1,
    LibfwVerdictReject = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwFirewall {
    _unused: [u8; 0],
}
#[doc = " A callback type for providing logs from\n library into VPN protocol implementation\n\n @level - log level as defined in @LIBFW_LOG_LEVEL\n @log_line - zero-terminated log line\n"]
pub type LibfwLogCallback = ::std::option::Option<
    unsafe extern "C" fn(level: LibfwLogLevel, log_line: *const ::std::os::raw::c_char),
>;
#[doc = " Information about a domain blocked by TP-Lite\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwBlockedDomain {
    pub domain_name: *const ::std::os::raw::c_char,
    pub record_type: u16,
    pub timestamp: u64,
    pub category: *const ::std::os::raw::c_char,
}
#[doc = " Count of some \"thing\". Intended to hold counts for record and response types\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwRRTypeCount_u16 {
    pub rr_type: u16,
    pub count: u32,
}
#[doc = " Count of some \"thing\". Intended to hold counts for record and response types\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwRRTypeCount_u8 {
    pub rr_type: u8,
    pub count: u32,
}
#[doc = " General metrics about DNS traffic\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwDnsMetrics {
    pub num_requests: u32,
    pub num_responses: u32,
    pub num_malformed_requests: u32,
    pub num_malformed_responses: u32,
    pub num_cache_hits: u32,
    pub record_type_distribution: *const LibfwRRTypeCount_u16,
    pub num_record_types: usize,
    pub response_code_distribution: *const LibfwRRTypeCount_u8,
    pub num_response_codes: usize,
}
#[doc = " Callback used by integrating libraries/apps for getting the collected TP-Lite stats\n\n @param data - A pointer meant to provide facilities for callback implementors\n               to add context information to the callback itself. If integrators\n               of libfirewall does not need context information - `null` may be passed.\n @param domains - list of domains that were blocked by TP-Lite DNS servers\n @param num_blocked_domains - number of elements in @ref domains\n @param metrics - general metrics about DNS traffic\n"]
pub type LibfwCollectTpLiteStatsCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        domains: *const LibfwBlockedDomain,
        num_blocked_domains: usize,
        metrics: LibfwDnsMetrics,
    ),
>;
#[doc = " Filter by the associate data\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwAssociatedData {
    #[doc = " Associated data"]
    pub associated_data: *const u8,
    #[doc = " Associated data length"]
    pub associated_data_len: usize,
}
#[doc = " IP data\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union LibfwIpData {
    #[doc = " Data for IPv4"]
    pub ipv4_bytes: [u8; 4usize],
    #[doc = " Data for IPv6"]
    pub ipv6_bytes: [u8; 16usize],
}
#[doc = " IP representation\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LibfwIpAddr {
    #[doc = " Type of the IP data:\n  - LIBFW_IP_TYPE_V4 - for IPv4 addresses\n  - LIBFW_IP_TYPE_V6 - for IPv6 addresses"]
    pub ip_type: u8,
    #[doc = " Data for the IP packet"]
    pub ip_data: LibfwIpData,
}
#[doc = " Filter by subnet and port range\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LibfwNetworkFilter {
    #[doc = " Network IP address"]
    pub network_addr: LibfwIpAddr,
    #[doc = " Network mask prefix"]
    pub network_prefix: u8,
    #[doc = " Minimum port accepted by the filter"]
    pub port_range_start: u16,
    #[doc = " Maximum port accepted by the filter"]
    pub port_range_end: u16,
}
#[doc = " Data for the certain filter type\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union LibfwFilterData {
    #[doc = " Checked associated data\n Use when filter_type = LibfwFilterAssociatedData"]
    pub associated_data_filter: LibfwAssociatedData,
    #[doc = " Checked conntrack state\n Use when filter_type = LibfwFilterConntrackState"]
    pub conntrack_state_filter: u8,
    #[doc = " Checked conntrack state\n Use when filter_type = LibfwFilterConntrackState"]
    pub network_filter: LibfwNetworkFilter,
    #[doc = " Checked packet direction\n Use when filter_type = LibfwFilterDirection"]
    pub direction_filter: u8,
    #[doc = " Checked next level protocol (UDP, TCP, ICMP and ICMPv6 are allowed)\n Use when filter_type = LibfwFilterNextLvlProto"]
    pub next_level_protocol: u8,
    #[doc = " Checked set of TCP flags - packet matches the filter if any of its flags matches any of `tcp_flags`\n Use when filter_type = LibfwFilterTcpFlags"]
    pub tcp_flags: u8,
    #[doc = " Checked ICMP types, only ICMP packets can match this filter\n Use when filter_type = LibfwFilterConntrackState"]
    pub icmp_type: u8,
}
#[doc = " Struct describing a single Libfw filter\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LibfwFilter {
    #[doc = " Filter may be inverted, meaning, that it is considered\n a match only if filter does *not* match"]
    pub inverted: bool,
    #[doc = " Defines a type of filter to match the packets against.\n There are a few possible filter types:\n * LIBFW_FILTER_ASSOCIATED_DATA - matches packets based on their associated data.\n   This Normally means public key for NordLynx\n * LIBFW_FILTER_CONNTRACK_STATE - matches connection tracking table state.\n   This can be either \"new connection\" or \"established connection\"\n * LIBFW_FILTER_[SRC|DST]_NETWORK - matches against either source or destination IP network\n * LIBFW_FILTER_DIRECTION - matches either inbound or outbound packet direction.\n * LIBFW_FILTER_NEXT_LVL_PROTO - matches next level protocol, which can be:\n    - TCP - when `filter` is equal to LIBFW_NEXT_PROTO_TCP\n    - UDP - when `filter` is equal to LIBFW_NEXT_PROTO_UDP\n    - ICMP - when `filter` is equal to LIBFW_NEXT_PROTO_ICMP\n    - ICMPv6 - when filter is equal to LIBFW_NEXT_PROTO_ICMPV6\n * LIBFW_FILTER_TCP_FLAGS - TCP packets with certain flags - data should be a logic sum of\n   the considered TCP flags, the packet matches it when any of its flags and any flag in\n   the provided filter set are the same\n * LIBFW_FILTER_ICMP_TYPE - ICMP packets with certain type:\n    - EchoReply when `filter` is equal to LIBFW_ICMP_TYPE_ECHO_REPLY\n    - DestinationUnreachable when `filter` is equal to LIBFW_ICMP_TYPE_DESTINATION_UNREACHABLE\n    - RedirectMessage when `filter` is equal to LIBFW_ICMP_TYPE_REDIRECT_MESSAGE\n    - EchoRequest when `filter` is equal to LIBFW_ICMP_TYPE_ECHO_REQUEST\n    - ReouterAdvertisement when `filter` is equal to LIBFW_ICMP_TYPE_ROUTER_ADVERTISEMENT\n    - RouterSolicitation when `filter` is equal to LIBFW_ICMP_TYPE_ROUTER_SOLICITATION\n    - TimeExceeded when `filter` is equal to LIBFW_ICMP_TYPE_TIME_EXCEEDED\n    - ParameterProblem when `filter` is equal to LIBFW_ICMP_TYPE_PARAMETER_PROBLEM\n    - Timestamp when `filter` is equal to LIBFW_ICMP_TYPE_TIMESTAMP\n    - TimestampReply when `filter` is equal to LIBFW_ICMP_TYPE_TIMESTAMP_REPLY"]
    pub filter_type: u8,
    #[doc = " Contains corresponding filter data"]
    pub filter: LibfwFilterData,
}
#[doc = " A definition of firewall rule it consists of filters which determine whether rule\n applies to packet being processed and action, which determins what to do with the packet"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwRule {
    #[doc = " List of filters all of which match in order to consider rule's action"]
    pub filters: *const LibfwFilter,
    #[doc = " Length of the filter list"]
    pub filter_count: usize,
    #[doc = " Defines an action to be taken when filter matches packet. Generally either accept\n and stop processing rule chain or drop and stop processing rule chain.\n\n Should have one of the LIBFW_VERDICT_* values:\n  - LIBFW_VERDICT_ACCEPT - packet matching the rule will be accepted\n  - LIBFW_VERDICT_DROP - packet matching the rule will be dropped\n  - LIBFW_VERDICT_REJECT - packet matching the rule should be dropped and reject\n    packet will be sent to the packet source"]
    pub action: u8,
}
#[doc = " A chain of rules.\n\n Rules are processed in order specified in the chain.\n If _some_ rule in the chain matches and a verdict is\n determined - the chain processing terminated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibfwChain {
    #[doc = " Chain size"]
    pub rule_count: usize,
    #[doc = " List of the rules"]
    pub rules: *const LibfwRule,
}
#[doc = " A callback type to enable libfirewall to\n inject packets into VPN tunnel interface\n\n Normally only called when stale connection\n closing is triggered.\n\n @param data - The same pointer as passed in @ref libfw_init. It is meant to\n              provide facilities for callback implementors to add context\n              information to the callback itself. If integrators of libfirewall\n              does not need context information - `null` may be passed in\n              @ref libfw_init\n @param packet - byte array of IP packet\n @param packet_len - length in bytes of IP packet in @param packet\n @param associated_data - if associated data was passed in inbound\n                          and outbound packet processing function\n                          this field will provide the same associated\n                          data. Inteded to be used as peer identifier\n                          in case of nordlynx\n @param associated_data_len - the length in bytes of associated data\n"]
pub type LibfwInjectPacketCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut ::std::os::raw::c_void,
        packet: *const u8,
        packet_len: usize,
        associated_data: *const u8,
        associated_data_len: usize,
    ),
>;

pub struct Libfirewall {
    __library: ::libloading::Library,
    pub libfw_set_log_callback:
        unsafe extern "C" fn(min_log_level: LibfwLogLevel, log_cb: LibfwLogCallback),
    pub libfw_init: unsafe extern "C" fn() -> *mut LibfwFirewall,
    pub libfw_enable_tp_lite_stats_collection: unsafe extern "C" fn(
        firewall: *mut LibfwFirewall,
        config: *const ::std::os::raw::c_char,
        collect_stats_cb_data: *mut ::std::os::raw::c_void,
        collect_stats_cb: LibfwCollectTpLiteStatsCallback,
    ) -> LibfwResult::Type,
    pub libfw_disable_tp_lite_stats_collection: unsafe extern "C" fn(firewall: *mut LibfwFirewall),
    pub libfw_configure_chain: unsafe extern "C" fn(
        fw: *mut LibfwFirewall,
        ffi_chain: *const LibfwChain,
    ) -> LibfwResult::Type,
    pub libfw_trigger_stale_connection_close: unsafe extern "C" fn(
        firewall: *mut LibfwFirewall,
        associated_data: *const u8,
        associated_data_len: usize,
        inject_packet_cb_data: *mut ::std::os::raw::c_void,
        inject_inbound_packet_cb: LibfwInjectPacketCallback,
        _inject_outbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwResult::Type,
    pub libfw_process_inbound_packet: unsafe extern "C" fn(
        firewall: *mut LibfwFirewall,
        packet: *mut u8,
        packet_len: usize,
        associated_data: *const u8,
        associated_data_len: usize,
        _inject_packet_cb_data: *mut ::std::os::raw::c_void,
        _inject_outbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwVerdict,
    pub libfw_process_outbound_packet: unsafe extern "C" fn(
        firewall: *mut LibfwFirewall,
        packet: *const u8,
        packet_len: usize,
        associated_data: *const u8,
        associated_data_len: usize,
        _inject_packet_cb_data: *mut ::std::os::raw::c_void,
        _inject_inbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwVerdict,
    pub libfw_deinit: unsafe extern "C" fn(firewall: *mut LibfwFirewall),
}

#[cfg_attr(test, mockall::automock)]
impl Libfirewall {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr> + 'static,
    {
        #[cfg(unix)]
        let library = ::libloading::os::unix::Library::open(
            Some(path),
            ::libloading::os::unix::RTLD_LAZY
                | ::libloading::os::unix::RTLD_LOCAL
                | libc::RTLD_NODELETE,
        )?;
        #[cfg(not(unix))]
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library> + 'static,
    {
        let __library = library.into();
        let libfw_set_log_callback = __library.get(b"libfw_set_log_callback\0").map(|sym| *sym)?;
        let libfw_init = __library.get(b"libfw_init\0").map(|sym| *sym)?;
        let libfw_enable_tp_lite_stats_collection = __library
            .get(b"libfw_enable_tp_lite_stats_collection\0")
            .map(|sym| *sym)?;
        let libfw_disable_tp_lite_stats_collection = __library
            .get(b"libfw_disable_tp_lite_stats_collection\0")
            .map(|sym| *sym)?;
        let libfw_configure_chain = __library.get(b"libfw_configure_chain\0").map(|sym| *sym)?;
        let libfw_trigger_stale_connection_close = __library
            .get(b"libfw_trigger_stale_connection_close\0")
            .map(|sym| *sym)?;
        let libfw_process_inbound_packet = __library
            .get(b"libfw_process_inbound_packet\0")
            .map(|sym| *sym)?;
        let libfw_process_outbound_packet = __library
            .get(b"libfw_process_outbound_packet\0")
            .map(|sym| *sym)?;
        let libfw_deinit = __library.get(b"libfw_deinit\0").map(|sym| *sym)?;
        Ok(Libfirewall {
            __library,
            libfw_set_log_callback,
            libfw_init,
            libfw_enable_tp_lite_stats_collection,
            libfw_disable_tp_lite_stats_collection,
            libfw_configure_chain,
            libfw_trigger_stale_connection_close,
            libfw_process_inbound_packet,
            libfw_process_outbound_packet,
            libfw_deinit,
        })
    }
    #[doc = " Setup logging\n\n Register a log callback which will receive\n and handle all logs from libfirewall\n\n @param min_log_level - minimum log level to produce logs. For debug builds\n                        LIBFW_TRACE is not available\n @param log_cb - callback for logs\n"]
    pub unsafe fn libfw_set_log_callback(
        &self,
        min_log_level: LibfwLogLevel,
        log_cb: LibfwLogCallback,
    ) {
        (self.libfw_set_log_callback)(min_log_level, log_cb)
    }
    #[doc = " A function used to initialize libfirewall instance\n\n @return pointer to initialized fw instance on success, NULL on failure\n"]
    pub unsafe fn libfw_init(&self) -> *mut LibfwFirewall {
        (self.libfw_init)()
    }
    #[doc = " Configure libfirewall to collect stats about domains blocked by TP-Lite\n Providing no IPs will disable the collection of TP-Lite stats\n\n @param firewall - pointer returned by @ref libfw_init\n @param config - json string containing config options. The valid fields are:\n                     - dns_server_ips: list of IP addresses as strings\n @param collect_stats_cb_data - a pointer which will be passed in the\n                                inject_packet callback unmodified\n @param collect_stats_cb - callback through which the collected stats are passed\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init`.\n\n The user must ensure that the collect_stats_cb_data pointer and\n collect_stats_cb function pointer lives as long as the firewall instance,\n or until libfw_disable_tp_lite_stats_collection is called"]
    pub unsafe fn libfw_enable_tp_lite_stats_collection(
        &self,
        firewall: *mut LibfwFirewall,
        config: *const ::std::os::raw::c_char,
        collect_stats_cb_data: *mut ::std::os::raw::c_void,
        collect_stats_cb: LibfwCollectTpLiteStatsCallback,
    ) -> LibfwResult::Type {
        (self.libfw_enable_tp_lite_stats_collection)(
            firewall,
            config,
            collect_stats_cb_data,
            collect_stats_cb,
        )
    }
    #[doc = " Deactivate TP-Lite stats collection by libfirewall\n\n @param firewall - pointer returned by @ref libfw_init\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init`."]
    pub unsafe fn libfw_disable_tp_lite_stats_collection(&self, firewall: *mut LibfwFirewall) {
        (self.libfw_disable_tp_lite_stats_collection)(firewall)
    }
    #[doc = " Configures chain of rules for the firewall to follow\n\n @param fw - pointer returned by @ref libfw_init\n @param chain - chain of the firewall rules\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init` and also dereferences `ffi_chain` pointer\n which should point to a valid LibfwChain struct.\n"]
    pub unsafe fn libfw_configure_chain(
        &self,
        fw: *mut LibfwFirewall,
        ffi_chain: *const LibfwChain,
    ) -> LibfwResult::Type {
        (self.libfw_configure_chain)(fw, ffi_chain)
    }
    #[doc = " A function which triggers stale connection closing\n\n @param fw - pointer returned by @ref libfw_init\n @param associated_data - identifier of peer. Should contain peer's public key\n                          for NordLynx and be Null for other protcols\n @param associated_data_len - size of @param associated_data in bytes\n @param inject_packet_cb_data - a pointer which will be passed in the\n                                inject_packet callback unmodified\n @param inject_inbound_packet_cb - callback which will be used by libfw to inject\n                           packets into virtual tunnel interface\n @param inject_outbound_packet_cb - callback which will be used by libfw to inject\n                          packets back towards VPN server. May be NULL if integrators\n                          accepts that libfirewall will only reject connections from\n                          inbound direction.\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init`."]
    pub unsafe fn libfw_trigger_stale_connection_close(
        &self,
        firewall: *mut LibfwFirewall,
        associated_data: *const u8,
        associated_data_len: usize,
        inject_packet_cb_data: *mut ::std::os::raw::c_void,
        inject_inbound_packet_cb: LibfwInjectPacketCallback,
        _inject_outbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwResult::Type {
        (self.libfw_trigger_stale_connection_close)(
            firewall,
            associated_data,
            associated_data_len,
            inject_packet_cb_data,
            inject_inbound_packet_cb,
            _inject_outbound_packet_cb,
        )
    }
    #[doc = " A function which processes inbound packets (coming from VPN server to device)\n\n @param fw - pointer returned by @ref libfw_init\n @param packet - pointer to byte array comprising of IP packet\n @param packet_len - size of packet in bytes\n @param associated_data - identifier of peer. Should contain peer's public key\n                          for NordLynx and be Null for other protcols\n @param associated_data_len - size of @param associated_data in bytes\n @param inject_packet_cb_data - a pointer which will be passed in the\n                                inject_packet callback unmodified\n @param inject_outbound_packet_cb - callback which will be used by libfw to inject\n                          packets back towards VPN server. May be NULL if integrators\n                          accepts that libfirewall will only reject connections from\n                          inbound direction.\n\n @return - returns LIBFW_VERDICT, integrators should allow packet to go through if\n           and only if function returns LIBFW_VERDICT_ACCEPT\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init` - and also `packet` and `associated_data`\n which must be allocated with valid lengts (`packet_len` and `associated_data_len`,\n respectively)."]
    pub unsafe fn libfw_process_inbound_packet(
        &self,
        firewall: *mut LibfwFirewall,
        packet: *mut u8,
        packet_len: usize,
        associated_data: *const u8,
        associated_data_len: usize,
        _inject_packet_cb_data: *mut ::std::os::raw::c_void,
        _inject_outbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwVerdict {
        (self.libfw_process_inbound_packet)(
            firewall,
            packet,
            packet_len,
            associated_data,
            associated_data_len,
            _inject_packet_cb_data,
            _inject_outbound_packet_cb,
        )
    }
    #[doc = " A function which processes outbound packets (coming from device to VPN server)\n\n @param fw - pointer returned by @ref libfw_init\n @param packet - pointer to byte array comprising of IP packet\n @param packet_len - size of packet in bytes\n @param associated_data - identifier of peer. Should contain peer's public key\n                          for NordLynx and be Null for other protcols\n @param associated_data_len - size of @param associated_data in bytes\n @param inject_packet_cb_data - a pointer which will be passed in the\n                                inject_packet callback unmodified\n @param inject_inbound_packet_cb - callback which will be used by libfw to inject\n                           packets into virtual tunnel interface\n\n @return - returns LIBFW_VERDICT, integrators should allow packet to go through if\n           and only if function retruns LIBFW_VERDICT_ACCEPT\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init` - and also `packet` and `associated_data`\n which must be allocated with valid lengts (`packet_len` and `associated_data_len`,\n respectively)."]
    pub unsafe fn libfw_process_outbound_packet(
        &self,
        firewall: *mut LibfwFirewall,
        packet: *const u8,
        packet_len: usize,
        associated_data: *const u8,
        associated_data_len: usize,
        _inject_packet_cb_data: *mut ::std::os::raw::c_void,
        _inject_inbound_packet_cb: LibfwInjectPacketCallback,
    ) -> LibfwVerdict {
        (self.libfw_process_outbound_packet)(
            firewall,
            packet,
            packet_len,
            associated_data,
            associated_data_len,
            _inject_packet_cb_data,
            _inject_inbound_packet_cb,
        )
    }
    #[doc = " Destructs firewall instance.\n\n After this function returns it is guaranteed that no callbacks will\n be called anymore.\n\n @param fw - pointer returned by @ref libfw_init\n\n # Safety\n\n This function dereferences pointer to firewall - user must ensure that this is\n the pointer returned by `libfw_init`."]
    pub unsafe fn libfw_deinit(&self, firewall: *mut LibfwFirewall) {
        (self.libfw_deinit)(firewall)
    }
}
