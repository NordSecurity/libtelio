use std::{collections::HashMap, time::Duration};
use tokio::time::Instant;

use telio_crypto::PublicKey;
use telio_model::{
    api_config::FeatureLinkDetection,
    mesh::{LinkState, NodeState},
};

/// Default wireguard keepalive duration
const WG_KEEPALIVE: Duration = Duration::from_secs(10);
/// Keepalive packets size
const KEEPALIVE_PACKET_SIZE: u64 = 32;

pub enum LinkDetection {
    Enabled(LinkDetectionEnabled),
    Disabled(LinkDetectionDisabled),
}

impl LinkDetection {
    pub fn new(features: Option<FeatureLinkDetection>) -> Self {
        match features {
            None => LinkDetection::Disabled(LinkDetectionDisabled::default()),
            Some(features) => LinkDetection::Enabled(LinkDetectionEnabled::new(
                Duration::from_secs(features.rtt_seconds),
            )),
        }
    }

    pub fn time_since_last_rx(&self, public_key: &PublicKey) -> Option<Duration> {
        match self {
            LinkDetection::Enabled(l) => l.time_since_last_rx(public_key),
            LinkDetection::Disabled(l) => l.time_since_last_rx(public_key),
        }
    }

    pub fn insert(
        &mut self,
        public_key: &PublicKey,
        rx_bytes: Option<u64>,
        tx_bytes: Option<u64>,
        link_state: LinkState,
    ) {
        match self {
            LinkDetection::Enabled(l) => l.insert(public_key, rx_bytes, tx_bytes, link_state),
            LinkDetection::Disabled(l) => l.insert(public_key, rx_bytes),
        }
    }

    pub fn update(
        &mut self,
        public_key: &PublicKey,
        rx_bytes: Option<u64>,
        tx_bytes: Option<u64>,
        node_state: NodeState,
        push: bool,
    ) -> LinkDetectionUpdateResult {
        match self {
            LinkDetection::Enabled(l) => l.update(public_key, rx_bytes, tx_bytes, node_state, push),
            LinkDetection::Disabled(l) => l.update(public_key, rx_bytes, push),
        }
    }

    pub fn remove(&mut self, public_key: &PublicKey) {
        match self {
            LinkDetection::Enabled(l) => l.remove(public_key),
            LinkDetection::Disabled(l) => l.remove(public_key),
        }
    }

    pub fn is_disabled(&self) -> bool {
        matches!(self, LinkDetection::Disabled(_))
    }
}

pub struct LinkDetectionEnabled {
    rtt: Duration,
    nodes_info: HashMap<PublicKey, NodeInfo>,
}

impl LinkDetectionEnabled {
    fn new(rtt: Duration) -> Self {
        LinkDetectionEnabled {
            rtt,
            nodes_info: HashMap::default(),
        }
    }

    fn time_since_last_rx(&self, public_key: &PublicKey) -> Option<Duration> {
        self.nodes_info
            .get(public_key)
            .map(|n| n.last_rx_timestamp.elapsed())
    }

    fn insert(
        &mut self,
        public_key: &PublicKey,
        rx_bytes: Option<u64>,
        tx_bytes: Option<u64>,
        link_state: LinkState,
    ) {
        let info = NodeInfo {
            last_rx_bytes: rx_bytes.unwrap_or_default(),
            last_tx_bytes: tx_bytes.unwrap_or_default(),
            last_link_state: link_state,
            ..Default::default()
        };
        self.nodes_info.insert(*public_key, info);
    }

    fn update(
        &mut self,
        public_key: &PublicKey,
        rx_bytes: Option<u64>,
        tx_bytes: Option<u64>,
        node_state: NodeState,
        push: bool,
    ) -> LinkDetectionUpdateResult {
        // We want to update info only on pull
        if push {
            let link_state = self
                .nodes_info
                .get(public_key)
                .map(|n| n.last_link_state)
                .unwrap_or_else(|| {
                    if matches!(node_state, NodeState::Connected) {
                        LinkState::Up
                    } else {
                        LinkState::Down
                    }
                });

            // Return with no notification generated by no link detection
            // And last known link_state.
            return self.build_result(false, node_state, link_state);
        }

        if let Some(old_info) = self.nodes_info.get(public_key) {
            let new_info = old_info.compute_new_node_info(rx_bytes, tx_bytes, self.rtt);
            let should_notify = if !matches!(node_state, NodeState::Connected) {
                false
            } else {
                old_info.last_link_state != new_info.last_link_state
            };

            let link_state = new_info.last_link_state;

            self.nodes_info.insert(*public_key, new_info);

            self.build_result(should_notify, node_state, link_state)
        } else {
            // Somehow we missed the node when it was new. We should recover from it.
            // To be less intrusive and to not disturb direct connections insert it with
            // LinkState according to the node connection state.
            let link_state = if matches!(node_state, NodeState::Connected) {
                LinkState::Up
            } else {
                LinkState::Down
            };
            self.insert(public_key, rx_bytes, tx_bytes, link_state);

            // No notification. We try to recover.
            self.build_result(false, node_state, link_state)
        }
    }

    fn remove(&mut self, public_key: &PublicKey) {
        self.nodes_info.remove(public_key);
    }

    fn build_result(
        &self,
        should_notify: bool,
        node_state: NodeState,
        link_state: LinkState,
    ) -> LinkDetectionUpdateResult {
        let link_state = if !matches!(node_state, NodeState::Connected) {
            LinkState::Down
        } else {
            link_state
        };

        LinkDetectionUpdateResult {
            should_notify,
            link_state: Some(link_state),
        }
    }
}

#[derive(Default)]
pub struct LinkDetectionDisabled {
    last_rx_info: HashMap<PublicKey, (u64, Instant)>,
}

impl LinkDetectionDisabled {
    fn time_since_last_rx(&self, public_key: &PublicKey) -> Option<Duration> {
        self.last_rx_info.get(public_key).map(|n| n.1.elapsed())
    }

    fn insert(&mut self, public_key: &PublicKey, rx_bytes: Option<u64>) {
        self.last_rx_info
            .insert(*public_key, (rx_bytes.unwrap_or_default(), Instant::now()));
    }

    fn update(
        &mut self,
        public_key: &PublicKey,
        rx_bytes: Option<u64>,
        push: bool,
    ) -> LinkDetectionUpdateResult {
        // We want to update info only on pull
        if !push {
            self.update_last_rx_info(public_key, rx_bytes);
        }

        LinkDetectionUpdateResult::default()
    }

    fn remove(&mut self, public_key: &PublicKey) {
        self.last_rx_info.remove(public_key);
    }

    fn update_last_rx_info(&mut self, public_key: &PublicKey, rx_bytes: Option<u64>) {
        if let Some((old_rx, _old_ts)) = self.last_rx_info.get(public_key) {
            let new_rx = rx_bytes.unwrap_or_default();
            if *old_rx != new_rx {
                self.last_rx_info
                    .insert(*public_key, (new_rx, Instant::now()));
            }
        } else {
            // Somehow we missed the node when it was new. We should recover from it.
            self.insert(public_key, rx_bytes);
        }
    }
}

#[derive(Default)]
pub struct LinkDetectionUpdateResult {
    pub should_notify: bool,
    pub link_state: Option<LinkState>,
}

#[derive(Clone, Copy, Debug)]
struct NodeInfo {
    last_tx_timestamp: Instant,
    last_rx_timestamp: Instant,
    last_tx_bytes: u64,
    last_rx_bytes: u64,
    last_link_state: LinkState,
}

impl Default for NodeInfo {
    fn default() -> Self {
        let now = Instant::now();
        NodeInfo {
            last_tx_timestamp: now,
            last_rx_timestamp: now,
            last_tx_bytes: 0,
            last_rx_bytes: 0,
            last_link_state: LinkState::Down,
        }
    }
}

impl NodeInfo {
    fn compute_new_node_info(
        &self,
        new_rx: Option<u64>,
        new_tx: Option<u64>,
        rtt: Duration,
    ) -> Self {
        let new_rx = new_rx.unwrap_or(self.last_rx_bytes);
        let new_tx = new_tx.unwrap_or(self.last_tx_bytes);

        let now = Instant::now();

        let (rx_bytes, rx_ts) = if new_rx > self.last_rx_bytes {
            (new_rx, now)
        } else {
            (self.last_rx_bytes, self.last_rx_timestamp)
        };

        let (tx_bytes, tx_ts) = if new_tx > self.last_tx_bytes {
            // Ignore the keepalive messages
            // This only works in a limited fashion because we poll every second and
            // the detection might not work as intended if there are more packets within that time window.
            // On the sender side persistent-keepalives might interfere as those are emitted regardless the activity,
            // meaning for example if persistent-keepalive is set at 5seconds then it might interfere with the
            // passive-keepalive which is a constant of 10seconds.
            let tx_ts = if new_tx - self.last_tx_bytes == KEEPALIVE_PACKET_SIZE {
                self.last_tx_timestamp
            } else {
                now
            };
            (new_tx, tx_ts)
        } else {
            (self.last_tx_bytes, self.last_tx_timestamp)
        };

        let link_state = if tx_ts <= rx_ts || rx_ts.elapsed() < WG_KEEPALIVE + rtt {
            LinkState::Up
        } else {
            LinkState::Down
        };

        NodeInfo {
            last_tx_timestamp: tx_ts,
            last_rx_timestamp: rx_ts,
            last_tx_bytes: tx_bytes,
            last_rx_bytes: rx_bytes,
            last_link_state: link_state,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::link_detection;
    use telio_model::{api_config::FeatureLinkDetection, mesh::Node};
    use tokio::time;

    #[test]
    fn test_is_disabled_config() {
        // Disabled
        let no_link_detection = LinkDetection::new(None);
        assert_eq!(no_link_detection.is_disabled(), true);

        // Enabled
        let features = FeatureLinkDetection { rtt_seconds: 1 };
        let no_link_detection = LinkDetection::new(Some(features));
        assert_eq!(no_link_detection.is_disabled(), false);
    }

    #[tokio::test(start_paused = true)]
    async fn test_time_since_last_rx_with_disabled_link_detection() {
        let mut ld = LinkDetectionDisabled::default();
        let key = PublicKey::default();

        assert_eq!(ld.time_since_last_rx(&key), None);

        // Insert
        ld.insert(&key, None);
        assert_eq!(ld.time_since_last_rx(&key), Some(Instant::now().elapsed()));
        ld.remove(&key);

        time::advance(Duration::from_secs(1)).await;

        // Insert with value
        ld.insert(&key, Some(5));
        let last_change = Instant::now();
        assert_eq!(ld.time_since_last_rx(&key), Some(last_change.elapsed()));

        time::advance(Duration::from_secs(1)).await;

        // Update with no change in rx_bytes, so there will be no timestamp update
        ld.update(&key, Some(5), false);
        assert_eq!(ld.time_since_last_rx(&key), Some(last_change.elapsed()));

        time::advance(Duration::from_secs(1)).await;

        // Update with different rx_bytes
        ld.update(&key, Some(10), false);
        assert_eq!(ld.time_since_last_rx(&key), Some(Instant::now().elapsed()));
    }

    #[tokio::test(start_paused = true)]
    async fn test_time_since_last_rx_with_enabled_link_detection() {
        let mut ld = LinkDetectionEnabled::new(Duration::from_secs(15));
        let key = PublicKey::default();

        assert_eq!(ld.time_since_last_rx(&key), None);

        // Insert
        ld.insert(&key, None, None, LinkState::Down);
        assert_eq!(ld.time_since_last_rx(&key), Some(Instant::now().elapsed()));
        ld.remove(&key);

        time::advance(Duration::from_secs(1)).await;

        // Insert with value
        ld.insert(&key, Some(5), None, LinkState::Down);
        let last_change = Instant::now();
        assert_eq!(ld.time_since_last_rx(&key), Some(last_change.elapsed()));

        time::advance(Duration::from_secs(1)).await;

        // Update with no change in rx_bytes, so there will be no timestamp update
        ld.update(&key, Some(5), None, NodeState::Connected, false);
        assert_eq!(ld.time_since_last_rx(&key), Some(last_change.elapsed()));

        time::advance(Duration::from_secs(1)).await;

        // Update with different rx_bytes
        ld.update(&key, Some(10), None, NodeState::Connected, false);
        assert_eq!(ld.time_since_last_rx(&key), Some(Instant::now().elapsed()));
    }

    #[tokio::test(start_paused = true)]
    async fn test_compute_new_node_info_with_no_link_state_updates() {
        let old = NodeInfo {
            last_rx_bytes: 5,
            last_tx_bytes: 5,
            last_rx_timestamp: Instant::now(),
            last_tx_timestamp: Instant::now(),
            last_link_state: LinkState::Up,
        };

        let check_node_info = |info: &NodeInfo,
                               rx: u64,
                               tx: u64,
                               rx_ts: Instant,
                               tx_ts: Instant,
                               link_state: LinkState| {
            assert_eq!(info.last_rx_timestamp, rx_ts);
            assert_eq!(info.last_tx_timestamp, tx_ts);

            assert_eq!(info.last_rx_bytes, rx);
            assert_eq!(info.last_tx_bytes, tx);

            assert_eq!(info.last_link_state, link_state);
        };

        time::advance(Duration::from_secs(1)).await;

        let new = old.compute_new_node_info(None, None, Duration::from_secs(15));
        check_node_info(
            &new,
            old.last_rx_bytes,
            old.last_tx_bytes,
            old.last_rx_timestamp,
            old.last_tx_timestamp,
            old.last_link_state,
        );

        let new = old.compute_new_node_info(Some(5), None, Duration::from_secs(15));
        check_node_info(
            &new,
            old.last_rx_bytes,
            old.last_tx_bytes,
            old.last_rx_timestamp,
            old.last_tx_timestamp,
            old.last_link_state,
        );

        let new = old.compute_new_node_info(Some(10), None, Duration::from_secs(15));
        check_node_info(
            &new,
            10,
            old.last_tx_bytes,
            Instant::now(),
            old.last_tx_timestamp,
            old.last_link_state,
        );

        let new = old.compute_new_node_info(None, Some(10), Duration::from_secs(15));
        check_node_info(
            &new,
            old.last_rx_bytes,
            10,
            old.last_rx_timestamp,
            Instant::now(),
            old.last_link_state,
        );

        // Sent Keepalive
        let new = old.compute_new_node_info(None, Some(37), Duration::from_secs(15));
        check_node_info(
            &new,
            old.last_rx_bytes,
            37,
            old.last_rx_timestamp,
            old.last_tx_timestamp,
            old.last_link_state,
        );
    }
}
