#!/bin/env python3

import asyncio
import blake3
import base64
import hashlib
import ipaddress
import json
import sys
import uuid

from aiohttp import web
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from cryptography.hazmat.primitives.asymmetric import x25519, rsa, ec
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.x509.oid import NameOID, ExtensionOID
import ipaddress

from pathlib import Path

# Add protobuf directory to path for all tests
# See: https://github.com/grpc/grpc/issues/29459#issuecomment-1652447028
protobuf_dir = Path(__file__).parent / "grpc_protobuf"
sys.path.insert(0, str(protobuf_dir))

import grpc  # type: ignore
import grpc_protobuf.ens_pb2
from grpc_protobuf.ens_pb2 import ChallengeResponse, ConnectionError
from grpc_protobuf.ens_pb2_grpc import LoginServicer, ENSServicer, add_LoginServicer_to_server, add_ENSServicer_to_server

# Synchronization between http controller api and grpc stub
error_event = asyncio.Event()
error_ready = None

class GrpcStub(LoginServicer, ENSServicer):
    def __init__(self):
        self.challenges = set()
        self.vpn_server_private_key = None

    async def GetChallenge(self, request, context):
        challenge = uuid.uuid4()
        print("GetChallenge", request, context, challenge)
        self.challenges.add(challenge)
        return ChallengeResponse(challenge=str(challenge))

    async def ConnectionErrors(self, request, context):
        print("ConnectionErrors", request, context)
        
        global error_event
        global error_ready
        
        while True:
            await error_event.wait()
            print("Yielded")
            if error_ready:
                yield ConnectionError(code=error_ready["code"], additional_info=error_ready["additional_info"])
            error_event.clear()

class AuthenticationInterceptor(grpc.aio.ServerInterceptor):
    def __init__(self, grpc_stub):
        self.grpc_stub = grpc_stub

    async def intercept_service(self, continuation, handler_call_details):
        CONTEXT = "ens-auth"
        def derive_key(context: bytes, secret: bytes) -> bytes:
            return blake3.blake3(secret, derive_key_context=context).digest()

        def keyed_hash(key: bytes, message: bytes) -> bytes:
            return blake3.blake3(message, key=key).digest()

        def authentication_tag(secret: bytes, message: bytes) -> bytes:
            key = derive_key(CONTEXT, secret)
            return keyed_hash(key, message)

        if handler_call_details.method == "/ens.ENS/ConnectionErrors":
            print("metadata: ", handler_call_details.invocation_metadata)
            metadata = dict(handler_call_details.invocation_metadata)
            auth_token = metadata.get('authentication')
            assert auth_token

            decoded_bytes = base64.b64decode(auth_token)
            assert len(decoded_bytes) == 80
            
            client_public_key, challenge_uuid_bytes, received_authentication_tag = decoded_bytes[:32], decoded_bytes[32:48], decoded_bytes[48:]
            challenge_uuid = uuid.UUID(bytes=challenge_uuid_bytes)
            # This will rise KeyError when the key is not present:
            self.grpc_stub.challenges.remove(challenge_uuid)
            
            client_public_key = x25519.X25519PublicKey.from_public_bytes(client_public_key)
            global grpc_server
            assert grpc_server.vpn_server_private_key
            shared_secret = grpc_server.vpn_server_private_key.exchange(client_public_key)
            authentication_tag = authentication_tag(shared_secret, decoded_bytes[:48])
            assert authentication_tag == received_authentication_tag
            
        ret = await continuation(handler_call_details)
        return ret

@dataclass
class TlsConfig:
    fingerprint: str
    leaf_key_pem: str
    leaf_cert_pem: str
    intermediate_cert_pem: str
    root_cert_der: bytes
    
def generate_certificate_chain(
    common_name: str,
    dns_names: list[str],
    ip_addrs: list[str],
):
    root_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    intermediate_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    leaf_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)

    # Root CA Certificate
    root_subject = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME, "LT"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "NordSec"),
        x509.NameAttribute(NameOID.COMMON_NAME, "NordSec Test Root CA"),
    ])
    
    root_cert = (
        x509.CertificateBuilder()
        .subject_name(root_subject)
        .issuer_name(root_subject)  # Self-signed
        .public_key(root_private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.utcnow() - timedelta(days=1))
        .not_valid_after(datetime.utcnow() + timedelta(days=7))
        .add_extension(
            x509.BasicConstraints(ca=True, path_length=2), critical=True
        )
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .add_extension(
            x509.SubjectKeyIdentifier.from_public_key(root_private_key.public_key()),
            critical=False,
        )
        .sign(root_private_key, hashes.SHA256())
    )

    # Intermediate CA Certificate
    intermediate_subject = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME, "LT"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "NordSec"),
        x509.NameAttribute(NameOID.COMMON_NAME, "NordSec Test Intermediate CA"),
    ])
    
    intermediate_cert = (
        x509.CertificateBuilder()
        .subject_name(intermediate_subject)
        .issuer_name(root_cert.subject)  # Signed by root
        .public_key(intermediate_private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.utcnow() - timedelta(hours=1))
        .not_valid_after(datetime.utcnow() + timedelta(days=7))
        .add_extension(
            x509.BasicConstraints(ca=True, path_length=0), critical=True
        )
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .add_extension(
            x509.SubjectKeyIdentifier.from_public_key(intermediate_private_key.public_key()),
            critical=False,
        )
        .add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(root_private_key.public_key()),
            critical=False,
        )
        .sign(root_private_key, hashes.SHA256())
    )

    # Leaf Certificate
    leaf_subject = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME, "LT"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "NordSec"),
        x509.NameAttribute(NameOID.COMMON_NAME, common_name),
    ])

    san_list = []
    for d in dns_names:
        san_list.append(x509.DNSName(d))
    for ip in ip_addrs:
        san_list.append(x509.IPAddress(ipaddress.ip_address(ip)))

    leaf_cert = (
        x509.CertificateBuilder()
        .subject_name(leaf_subject)
        .issuer_name(intermediate_cert.subject)
        .public_key(leaf_private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.utcnow() - timedelta(minutes=1))
        .not_valid_after(datetime.utcnow() + timedelta(days=7))
        .add_extension(x509.SubjectAlternativeName(san_list), critical=False)
        .add_extension(
            x509.BasicConstraints(ca=False, path_length=None), critical=True
        )
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=True,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .add_extension(
            x509.ExtendedKeyUsage([
                x509.oid.ExtendedKeyUsageOID.SERVER_AUTH,
                x509.oid.ExtendedKeyUsageOID.CLIENT_AUTH,
            ]),
            critical=True,
        )
        .add_extension(
            x509.SubjectKeyIdentifier.from_public_key(leaf_private_key.public_key()),
            critical=False,
        )
        .add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(intermediate_private_key.public_key()),
            critical=False,
        )
        .sign(intermediate_private_key, hashes.SHA256())  # Signed by intermediate's private key
    )

    leaf_cert_der = leaf_cert.public_bytes(serialization.Encoding.DER)
    fingerprint = hashlib.sha256(leaf_cert_der).hexdigest()
    
    root_cert_der = root_cert.public_bytes(serialization.Encoding.DER)
    intermediate_cert_pem = intermediate_cert.public_bytes(serialization.Encoding.PEM)
    leaf_cert_pem = leaf_cert.public_bytes(serialization.Encoding.PEM)
    
    leaf_key_pem = leaf_private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    
    return TlsConfig(fingerprint, leaf_key_pem, leaf_cert_pem, intermediate_cert_pem, root_cert_der)


async def handle_connection_error(request):
    try:
        data = await request.json()
        print(f"got {data} on /api/connection_error")
        
        global error_event
        global error_ready
        error_ready = data
        print("will set event")
        error_event.set()
        print("did set event")
        
        return web.json_response({})
        
    except json.JSONDecodeError:
        return web.json_response({"error": "Invalid JSON"}, status=400)

async def handle_vpn_server_private_key(request):
    data = await request.json()
    print(f"got {data} on /api/vpn_server_private_key")
    vpn_server_private_key = base64.b64decode(data["vpn_server_private_key"])
    vpn_server_private_key = x25519.X25519PrivateKey.from_private_bytes(vpn_server_private_key)
    global grpc_server
    grpc_server.vpn_server_private_key = vpn_server_private_key
    return web.json_response({})
    
def handle_grpc_tls_fingerprint(fingerprint):
    async def handler(request):
        return web.json_response({"fingerprint": fingerprint})
    return handler

async def start_http_server(host, port, tls_config):
    app = web.Application()
    app.router.add_post('/api/connection_error', handle_connection_error)
    app.router.add_post('/api/vpn_server_private_key', handle_vpn_server_private_key)
    app.router.add_get('/api/grpc_tls_fingerprint', handle_grpc_tls_fingerprint(tls_config.fingerprint))
    app.router.add_get('/api/grpc_tls_root_certificate', handle_grpc_tls_root_certificate(tls_config.root_cert_der))
    app.router.add_get('/api/incorrect_root_certificate', handle_incorrect_root_certificate)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, host, port)
    await site.start()
    
    print(f"HTTP server started at http://{host}:{port}")
    return runner


def handle_grpc_tls_root_certificate(root_certificate):
    async def handler(request):
        encoded = base64.b64encode(root_certificate).decode('ascii')
        return web.json_response({"root_certificate": encoded })
    return handler


async def handle_incorrect_root_certificate(request):
    root_private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    root_subject = x509.Name([
        x509.NameAttribute(NameOID.COUNTRY_NAME, "LT"),
        x509.NameAttribute(NameOID.ORGANIZATION_NAME, "NordSec"),
        x509.NameAttribute(NameOID.COMMON_NAME, "NordSec Root CA"),
    ])
    
    root_cert = (
        x509.CertificateBuilder()
        .subject_name(root_subject)
        .issuer_name(root_subject)  # Self-signed
        .public_key(root_private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.utcnow() - timedelta(days=1))
        .not_valid_after(datetime.utcnow() + timedelta(days=7))
        .add_extension(
            x509.BasicConstraints(ca=True, path_length=2), critical=True
        )
        .add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False,
            ),
            critical=True,
        )
        .add_extension(
            x509.SubjectKeyIdentifier.from_public_key(root_private_key.public_key()),
            critical=False,
        )
        .sign(root_private_key, hashes.SHA256())
    )
    root_certificate = root_cert.public_bytes(serialization.Encoding.DER)
    encoded = base64.b64encode(root_certificate).decode('ascii')

    return web.json_response({"root_certificate": encoded })


async def start_grpc_server(chain):
    
    server_creds = grpc.ssl_server_credentials(
        private_key_certificate_chain_pairs=chain,
        root_certificates=None,
        require_client_auth=False,
    )
    grpc_stub = GrpcStub()
    auth_interceptor = AuthenticationInterceptor(grpc_stub)
    server = grpc.aio.server(interceptors=[auth_interceptor])
    
    add_LoginServicer_to_server(grpc_stub, server)
    add_ENSServicer_to_server(grpc_stub, server)
    server.add_secure_port("[::]:993", server_creds)
    print("Will start the ENS grpc service")
    await server.start()
    return server

async def main():
    tls_config = generate_certificate_chain(
        common_name="localhost",
        dns_names=["localhost"],
        ip_addrs=["127.0.0.1"],
    )
    fingerprint = tls_config.fingerprint
    leaf_cert_pem, leaf_key_pem = tls_config.leaf_cert_pem, tls_config.leaf_key_pem
    intermediate_cert_pem = tls_config.intermediate_cert_pem

    print(f"Generated gRPC TLS certificate with fingerprint: {fingerprint}")
    
    print("Starting test api")
    http_runner = await start_http_server(host="0.0.0.0", port=8000, tls_config=tls_config)
    
    print("Starting ENS")
    global grpc_server
    chain_pem = leaf_cert_pem + intermediate_cert_pem
    grpc_server = await start_grpc_server([(leaf_key_pem, chain_pem)])
    
    try:
        await grpc_server.wait_for_termination()
    except KeyboardInterrupt:
        print("Shutting down servers...")
    finally:
        await grpc_server.stop(5)
        await http_runner.cleanup()
        print("Servers terminated")

if __name__ == "__main__":
    asyncio.run(main())
