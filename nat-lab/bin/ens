#!/bin/env python3

import asyncio
import blake3
import base64
import hashlib
import ipaddress
import json
import sys
import uuid


from aiohttp import web
from datetime import datetime, timedelta
from cryptography.hazmat.primitives.asymmetric import x25519, rsa
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.x509 import NameOID
from pathlib import Path

# Add protobuf directory to path for all tests
# See: https://github.com/grpc/grpc/issues/29459#issuecomment-1652447028
protobuf_dir = Path(__file__).parent / "grpc_protobuf"
sys.path.insert(0, str(protobuf_dir))

import grpc  # type: ignore
import grpc_protobuf.ens_pb2
from grpc_protobuf.ens_pb2 import ChallengeResponse, ConnectionError
from grpc_protobuf.ens_pb2_grpc import LoginServicer, ENSServicer, add_LoginServicer_to_server, add_ENSServicer_to_server

grpc_tls_fingerprint = None
# Synchronization between http controller api and grpc stub
error_event = asyncio.Event()
error_ready = None

class GrpcStub(LoginServicer, ENSServicer):
    def __init__(self):
        self.challenges = set()
        self.vpn_server_private_key = None

    async def GetChallenge(self, request, context):
        challenge = uuid.uuid4()
        print("GetChallenge", request, context, challenge)
        self.challenges.add(challenge)
        return ChallengeResponse(challenge=str(challenge))

    async def ConnectionErrors(self, request, context):
        print("ConnectionErrors", request, context)
        
        global error_event
        global error_ready
        
        while True:
            await error_event.wait()
            print("Yielded")
            if error_ready:
                yield ConnectionError(code=error_ready["code"], additional_info=error_ready["additional_info"])
            error_event.clear()

class AuthenticationInterceptor(grpc.aio.ServerInterceptor):
    def __init__(self, grpc_stub):
        self.grpc_stub = grpc_stub

    async def intercept_service(self, continuation, handler_call_details):
        CONTEXT = "ens-auth"
        def derive_key(context: bytes, secret: bytes) -> bytes:
            return blake3.blake3(secret, derive_key_context=context).digest()

        def keyed_hash(key: bytes, message: bytes) -> bytes:
            return blake3.blake3(message, key=key).digest()

        def authentication_tag(secret: bytes, message: bytes) -> bytes:
            key = derive_key(CONTEXT, secret)
            return keyed_hash(key, message)

        if handler_call_details.method == "/ens.ENS/ConnectionErrors":
            print("metadata: ", handler_call_details.invocation_metadata)
            metadata = dict(handler_call_details.invocation_metadata)
            auth_token = metadata.get('authentication')
            assert auth_token

            decoded_bytes = base64.b64decode(auth_token)
            assert len(decoded_bytes) == 80
            
            client_public_key, challenge_uuid_bytes, received_authentication_tag = decoded_bytes[:32], decoded_bytes[32:48], decoded_bytes[48:]
            challenge_uuid = uuid.UUID(bytes=challenge_uuid_bytes)
            # This will rise KeyError when the key is not present:
            self.grpc_stub.challenges.remove(challenge_uuid)
            
            client_public_key = x25519.X25519PublicKey.from_public_bytes(client_public_key)
            global grpc_server
            assert grpc_server.vpn_server_private_key
            shared_secret = grpc_server.vpn_server_private_key.exchange(client_public_key)
            authentication_tag = authentication_tag(shared_secret, decoded_bytes[:48])
            assert authentication_tag == received_authentication_tag
            
        ret = await continuation(handler_call_details)
        return ret

def generate_self_signed_cert(
    common_name: str,
    dns_names: list[str],
    ip_addrs: list[str],
):
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=1024)

    subject = issuer = x509.Name(
        [
            x509.NameAttribute(NameOID.COUNTRY_NAME, "LT"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "NordSec"),
            x509.NameAttribute(NameOID.COMMON_NAME, common_name),
        ]
    )

    san_list = []
    for d in dns_names:
        san_list.append(x509.DNSName(d))
    for ip in ip_addrs:
        san_list.append(x509.IPAddress(ipaddress.ip_address(ip)))

    cert = (
        x509.CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(private_key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.utcnow() - timedelta(minutes=1))
        .not_valid_after(datetime.utcnow() + timedelta(days=7))
        .add_extension(x509.SubjectAlternativeName(san_list), critical=False)
        .add_extension(
            x509.BasicConstraints(ca=False, path_length=None), critical=True
        )
        .sign(private_key, hashes.SHA256())
    )

    cert_der = cert.public_bytes(serialization.Encoding.DER)
    fingerprint = hashlib.sha256(cert_der).hexdigest()
    print(f"cert fingerprint: {fingerprint}")
    global grpc_tls_fingerprint
    grpc_tls_fingerprint = fingerprint

    cert_pem = cert.public_bytes(serialization.Encoding.PEM)
    key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    )
    return cert_pem, key_pem

async def handle_connection_error(request):
    try:
        data = await request.json()
        print(f"got {data} on /api/connection_error")
        
        global error_event
        global error_ready
        error_ready = data
        print("will set event")
        error_event.set()
        print("did set event")
        
        return web.json_response({})
        
    except json.JSONDecodeError:
        return web.json_response({"error": "Invalid JSON"}, status=400)

async def handle_vpn_server_private_key(request):
    data = await request.json()
    print(f"got {data} on /api/vpn_server_private_key")
    vpn_server_private_key = base64.b64decode(data["vpn_server_private_key"])
    vpn_server_private_key = x25519.X25519PrivateKey.from_private_bytes(vpn_server_private_key)
    global grpc_server
    grpc_server.vpn_server_private_key = vpn_server_private_key
    return web.json_response({})
    

async def handle_grpc_tls_fingerprint(request):
    global grpc_tls_fingerprint
    return web.json_response({"fingerprint": grpc_tls_fingerprint})

async def start_http_server(host, port):
    app = web.Application()
    app.router.add_post('/api/connection_error', handle_connection_error)
    app.router.add_post('/api/vpn_server_private_key', handle_vpn_server_private_key)
    app.router.add_get('/api/grpc_tls_fingerprint', handle_grpc_tls_fingerprint)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, host, port)
    await site.start()
    
    print(f"HTTP server started at http://{host}:{port}")
    return runner

async def start_grpc_server(cert_pem, key_pem):
    server_creds = grpc.ssl_server_credentials(
        private_key_certificate_chain_pairs=[(key_pem, cert_pem)],
        root_certificates=None,
        require_client_auth=False,
    )
    grpc_stub = GrpcStub()
    auth_interceptor = AuthenticationInterceptor(grpc_stub)
    server = grpc.aio.server(interceptors=[auth_interceptor])
    
    add_LoginServicer_to_server(grpc_stub, server)
    add_ENSServicer_to_server(grpc_stub, server)
    server.add_secure_port("[::]:993", server_creds)
    print("Will start the ENS grpc service")
    await server.start()
    return server

async def main():
    cert_pem, key_pem = generate_self_signed_cert(
        common_name="localhost",
        dns_names=["localhost"],
        ip_addrs=["127.0.0.1"],
    )

    print("Starting test api")
    http_runner = await start_http_server(host="0.0.0.0", port=8000)
    
    print("Starting ENS")
    global grpc_server
    grpc_server = await start_grpc_server(cert_pem, key_pem)
    
    try:
        await grpc_server.wait_for_termination()
    except KeyboardInterrupt:
        print("Shutting down servers...")
    finally:
        await grpc_server.stop(5)
        await http_runner.cleanup()
        print("Servers terminated")

if __name__ == "__main__":
    asyncio.run(main())
